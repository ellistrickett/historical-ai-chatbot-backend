import { jest } from '@jest/globals';

// Mock dependencies
jest.unstable_mockModule(
  '../../../repositories/chatHistoryRepository.js',
  () => ({
    readChatsFile: jest.fn(),
    writeChatsFile: jest.fn(),
  })
);

jest.unstable_mockModule('../../../services/aiService.js', () => ({
  generateSummaryTitle: jest.fn(),
}));

jest.unstable_mockModule('uuid', () => ({
  v4: jest.fn().mockReturnValue('mock-uuid'),
}));

// Dynamic imports
const { readChatsFile, writeChatsFile } = await import(
  '../../../repositories/chatHistoryRepository.js'
);
const { generateSummaryTitle } = await import('../../../services/aiService.js');
const { saveChat, deleteChatById, getChatSummaries, getChatById } = await import(
  '../../../services/chatHistoryService.js'
);

describe('Chat History Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

describe('saveChat', () => {
  it('saves a new chat with generated title and returns ID', async () => {
    // 1. Setup Mocks
    readChatsFile.mockResolvedValue([]); // Start with empty storage
    generateSummaryTitle.mockResolvedValue('New Title'); // Mock AI service

    const newChatInput = { messages: [{ text: 'Hi' }] };

    // 2. Execute
    const returnedId = await saveChat(newChatInput);

    // 3. Assertions: Verify Return Value
    expect(returnedId).toBeDefined();
    expect(typeof returnedId).toBe('string'); // Expect a UUID string

    // 4. Assertions: Verify what was supposedly written to the file
    expect(writeChatsFile).toHaveBeenCalledTimes(1);
    
    // Inspect the data passed to writeChatsFile
    // .mock.calls[0][0] means: First call, First argument
    const chatsPassedToSave = writeChatsFile.mock.calls[0][0];
    const savedChat = chatsPassedToSave[0];

    expect(savedChat.id).toBe(returnedId);         // ID matches return value
    expect(savedChat.title).toBe('New Title');     // Title was generated by AI
    expect(savedChat.date).toBeDefined();          // Date was generated
    expect(savedChat.messages).toEqual(newChatInput.messages);
  });

});

  describe('deleteChatById', () => {
    it('deletes a chat successfully', async () => {
      readChatsFile.mockResolvedValue([{ id: '1' }, { id: '2' }]);

      const result = await deleteChatById('1');

      expect(result).toBe(true);
      expect(writeChatsFile).toHaveBeenCalledWith([{ id: '2' }]);
    });

    it('returns false if chat not found', async () => {
      readChatsFile.mockResolvedValue([{ id: '1' }]);

      const result = await deleteChatById('999');

      expect(result).toBe(false);
      expect(writeChatsFile).not.toHaveBeenCalled();
    });

    it('updates an existing chat and preserves original fields (Merge Logic)', async () => {
      // 1. Setup: Existing chat in the "database"
      const existingChat = { 
        id: 'existing-id-123', 
        title: 'Old Title', 
        personaName: 'Wizard',
        date: '2023-01-01T00:00:00.000Z',
        messages: [{ role: 'user', content: 'hello' }] 
      };
      
      // Mock that the file system returns this chat
      readChatsFile.mockResolvedValue([existingChat]);

      // 2. Input: Update payload 
      // Notice we are NOT sending 'date' or 'personaName'
      const updatePayload = {
        id: 'existing-id-123',
        title: 'New Updated Title',
        messages: [{ role: 'user', content: 'hello' }, { role: 'ai', content: 'hi' }]
      };

      // 3. Execute
      const resultId = await saveChat(updatePayload);

      // 4. Verification
      expect(resultId).toBe('existing-id-123');
      expect(writeChatsFile).toHaveBeenCalledTimes(1);

      // Inspect what was saved
      const chatsPassedToSave = writeChatsFile.mock.calls[0][0];
      const savedChat = chatsPassedToSave[0];

      // CHECK PRESERVATION: Existing fields should not be wiped
      expect(savedChat.date).toBe('2023-01-01T00:00:00.000Z'); 
      expect(savedChat.personaName).toBe('Wizard');            

      // CHECK UPDATES: New fields should be applied
      expect(savedChat.title).toBe('New Updated Title');       
      expect(savedChat.messages).toHaveLength(2);              
    });

    it('updates an existing chat but generates AI title if currently untitled', async () => {
      // 1. Setup: Existing chat that has no title yet
      const existingChat = { 
        id: 'existing-id-456', 
        title: undefined, // No title
        date: '2023-01-01T00:00:00.000Z' 
      };
      
      readChatsFile.mockResolvedValue([existingChat]);
      generateSummaryTitle.mockResolvedValue('AI Generated Title');

      // 2. Input: Add messages, but still no title provided by user
      const updatePayload = {
        id: 'existing-id-456',
        messages: [{ text: 'Some long conversation...' }]
      };

      // 3. Execute
      await saveChat(updatePayload);

      // 4. Verification
      const savedChat = writeChatsFile.mock.calls[0][0][0];
      
      expect(generateSummaryTitle).toHaveBeenCalled();
      expect(savedChat.title).toBe('AI Generated Title');
    });
  });

  describe('getChatSummaries', () => {
    it('returns chat summaries correctly with defaults', async () => {
      const mockChats = [
        { id: '1', title: 'T1', personaName: 'P1', date: '2023-01-01' },
      ];
      readChatsFile.mockResolvedValue(mockChats);

      const summaries = await getChatSummaries();
      expect(summaries.chats).toHaveLength(1);
      expect(summaries.total).toBe(1);
    });

    it('paginates correctly (page 2)', async () => {
      const mockChats = Array(10).fill().map((_, i) => ({ id: `${i}`, title: `T${i}` }));
      readChatsFile.mockResolvedValue(mockChats);

      // We pass Integers because the Controller is responsible for parseInt
      const result = await getChatSummaries(2, 3); 
      
      // Page 1: 0,1,2. Page 2: 3,4,5.
      expect(result.chats).toHaveLength(3);
      expect(result.chats[0].id).toBe('3');
    });
  });

  describe('getChatById', () => {
    it('returns chat if found', async () => {
      const mockChat = { id: '123', title: 'Test' };
      readChatsFile.mockResolvedValue([mockChat]);

      const result = await getChatById('123');
      expect(result).toEqual(mockChat);
    });

    it('throws 404 if chat not found', async () => {
      readChatsFile.mockResolvedValue([]);

      await expect(getChatById('999')).rejects.toThrow('Chat not found');
      await expect(getChatById('999')).rejects.toMatchObject({ statusCode: 404 });
    });
  });
});
